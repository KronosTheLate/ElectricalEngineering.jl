export j, pol, phasor, phasorsine

doc"""
`j = 1im` equals the imaginary unit
"""
const j=1im

doc"""
# Function call

`pol(r, phi)`

# Description

Creates a complex quantity with length `r` and angle `phi`

# Variables

`r` Length of complex quantity; r may be utilized including a unit generated by
Unitful

`phi` Angle of complex quantity; if module Unitful is utilized, the angle may be
specified in degrees, by using unit `°`

# Examples

```julia
julia> using Unitful, Unitful.DefaultSymbols, EE
julia> U1 = pol(2V,pi)
-2 + 0im V
julia> U2 = pol(sqrt(2)*1V,45°)
1 + 1im V
```
"""
function pol(r, phi)
  return r*cos(phi) + 1im*r*sin(phi)
end

doc"""
# Function call

`phasor(c;origin=0.0+0.0im, ref=1, par=0,
    labelrsep=0.5, labeltsep=0.1, label="", ha="center", va="center",
    labelrelrot=false, labelrelangle=0,
    color="black", linesstyle="-", linewidth=1,
    width=0.2, headlength=10, headwidth=5)`

# Description

This function draws a phasor from a starting point `origin` and end point
`origin`+`c`. The phasor consists of a shaft and an arrow head.

Each phasor c is plotted as a relative quantity, i.e., `c/ref` is actually
shown the plot figure. This concept of plotting a per unit phasor is used to
be able to plot phasor with different quantities, e.g., voltage and current
phasors. It is important that the variables `c`, `origin` and `ref` have the
same units (defined through Unitful).

# Variables

`c` Complex phasor, drawn relative relative to `origin`

`origin` Complex number representing the origin of the phasor; this variable
needs to have the same unit as `c`

`ref` Reference length of scaling; this is required as in a phasor diagram
voltages and currents may be included; in order to account for the different
voltage and current scales, one (constant)  `ref` is used for voltage
phasors and another (constant) `ref` is used for current phasors; this
variable needs to have the same unit as `c`

`par` In order to be able to plot parallel phasors, par is used to specify
the per unit tangential shift (offset) of a phasor, with respect to `ref`;
so typically `ref` will be selected to be around 0.05 to 0.1;
default value = 0 (no shift of phasor)

`labelrsep` Radial per unit location of label (in direction of the phasor):
`labelrsep = 0` represents the shaft of the phasor and `labelrsep = 1` represents
the arrow hear of the phasor; default value = 0.5, i.e., the radial center
of the phasor

`labeltsep` Tangential per unit location of label: `labeltsep = 0` means that the
label is plotted onto the phasor; `labeltsep = 0.1` plots the label on top of
the phasor applying a displacement of 10% with respect to `ref`;
`labeltsep = -0.2` Plots the label below the
phasor applying a displacement of 20% with respect to `ref`; default value
= 0.1

`ha` Horizontal alignment of label; actually represents the tangential
alignment of the label; default value = "center"

`va` Vertical alignment of label; actually represents the radial
alignment of the label; default value = "center"

`labelrelrot` Relative rotation of label; if `labelrelrot == false` (default value)
then the label is not rotated relative to the orientation of the phasor;
otherwise the label is rotated relative to the phasor by the angle
`labelrelangle` (indicated in degrees)

`labelrelangle` Relative angle of label in degree with respect to phasor
orientation; this angle is only applied, it `labelrelrot == true`; this angle the
indicates the relative orientation of the label with respect to the
orientation of the phasor; default value = 0

`color` Color of the phasor; i.e., shaft and arrow head color; default
value = "black"

`linestyle` Line style of the phasor; default value = "-"

`linewidth` Line width of the phasor; default value = 1

`width` Line width of the shaft line; default value = 0.2

`headlength` Length of arrow head; default value = 10

`headwidth` Width of arrow head; default value = 5

# Example

Copy and paste code:

```julia
using Unitful, Unitful.DefaultSymbols, PyPlot, EE
figure(figsize=(3.3, 2.5))
rc("text", usetex=true);
rc("font", family="serif")

V1 = 100V + j*0V # Voltage
Z1 = 30Ω + j*40Ω # Impedance
I1 = V1/Z1 # Current
Vr = real(Z1)*I1
Vx = V1 - Vr
refV = abs(V1); refI=abs(I1)*0.8
phasor(V1, label=L"$\underline{V}_1$", labeltsep=0.1, ref=refV, labelrelrot=true)
phasor(Vr, label=L"$\underline{V}_r$", labeltsep=0.1, ref=refV, labelrelrot=true)
phasor(Vx, origin=Vr, label=L"$\underline{V}_x$", labeltsep=-0.15, ref=refV, labelrelrot=true)
phasor(I1, label=L"$\underline{I}_1$", labeltsep=-0.2, labelrsep=0.7, ref=refI, labelrelrot=true, linestyle="--", par=0.05)
axis("square"); xlim(-1,1); ylim(-1,1)
removeaxes(); # Remove axis
# save3fig("phasordiagram",crop=true);
```
"""
function phasor(c;
    origin = (0.0+0.0im).*c./ustrip(c),
    ref = abs(c./ustrip(c)),
    par = 0.0,
    labelrsep = 0.5,
    labeltsep = 0.1,
    label = "",
    ha = "center",
    va = "center",
    labelrelrot = false,
    labelrelangle = 0.0,
    color = "black",
    linestyle = "-",
    linewidth = 1,
    width = 0.2,
    headlength = 10.0,
    headwidth = 5.0)

    # Check if units of c, origin and ref are compatible
    # Starting point (origin) of phase
    xorigin = 0.0
    yorigin = 0.0
    xend = 0.0
    yend = 0.0
    try
        xorigin = uconvert(Unitful.NoUnits, real(origin)./ref)
        yorigin = uconvert(Unitful.NoUnits, imag(origin)./ref)
        # End point of phasor
        xend = uconvert(Unitful.NoUnits, real(origin+c)./ref)
        yend = uconvert(Unitful.NoUnits, imag(origin+c)./ref)
    catch err
        error("module EE: function phasor: Dimension mismatch of arguments `c`, `origin` and `ref`\n    The arguments `c`, `origin` and `ref` must have the same dimension (koherent SI unit)")
    end

    # Real part of phasor
    drx = xend - xorigin # = real(c)./ref
    # Imag part of phasor
    dry = yend - yorigin # = imag(c)./ref
    # Length of phasor
    dr = sqrt(drx^2 + dry^2)
    # Angle of phasor in degrees
    absangle = atan2(dry, drx)*180/pi
    # Orientation tangential to phasor (lagging by 90°)
    # Real part of tangential component with repsect to length
    dtx = +dry/dr
    # Imag part of tangential component with repsect to length
    dty = -drx/dr
    # Real part of parallel shift of phasor
    dpx = par*dtx
    # Imag part of parallel shift of phasor
    dpy = par*dty
    # Origin of head
    xoriginHead = xorigin + drx*0.99
    yoriginHead = yorigin + dry*0.99
    # Draw arrow shaft and head
    # https://matplotlib.org/api/_as_gen/matplotlib.pyplot.annotate.html?highlight=annotate#matplotlib.pyplot.annotate
    # Draw shaft separately: otherwise, the arrow contour will be drawn as in
    # https://matplotlib.org/users/annotations.html#basic-annotation
    # so that the back and forth paths overlap and the line style does not
    # appear correctly; replace
    plot([xorigin+dpx,xend+dpx], [yorigin+dpy,yend+dpy],
        color=color, linestyle=linestyle, linewidth=linewidth)
    # Code based on plot replaces the previous implementation inspired by:
    # https://stackoverflow.com/questions/51746400/linestyle-in-plot-and-annotate-are-not-equal-in-matplotlib
    # Previous (obsolete) implementation:
    # annotate("", xy=(xend+dpx,yend+dpy),
    #     xytext=(xorigin+dpx,yorigin+dpy), xycoords="data",
    #     arrowprops=Dict("arrowstyle"=>"-",
    #         "linestyle"=>linestyle,
    #         "linewidth"=>linewidth,
    #         "color"=>color,
    #         "facecolor"=>color),
    #     annotation_clip=false)

    # Draw arrow head without line style; this is a workaround explained in
    # https://stackoverflow.com/questions/47180328/pyplot-dotted-line-with-fancyarrowpatch/47205418#47205418
    annotate("", xy=(xend+dpx, yend+dpy),
        xytext=(xoriginHead+dpx, yoriginHead+dpy), xycoords="data",
        arrowprops=Dict("edgecolor"=>color, "facecolor"=>color,
            "width"=>width, "linestyle"=>"-",
            "headlength"=>headlength,
            "headwidth"=>headwidth),
        annotation_clip=false)

    # Plot label
    if labelrelrot == false
        # Without relative rotation of label
        text(xorigin + drx*labelrsep - dtx*labeltsep + dpx,
            yorigin + dry*labelrsep - dty*labeltsep + dpy,
            label, ha=ha, va=va, rotation=labelrelangle)
    else
        # Applying relative rotation of label
        text(xorigin + drx*labelrsep - dtx*labeltsep + dpx,
            yorigin + dry*labelrsep - dty*labeltsep + dpy,
            label, ha=ha, va=va, rotation=absangle+labelrelangle)
    end
end

doc"""
# Function call

`phasorsine(mag = 1, phi = 0; add = false, figsize = (6.6,2.5),
    xlabel = L"$\omega t$\,($^\circ $)", ylabel = "", maglabel = "",
    phasorlabel = maglabel, labeltsep = 0.1, labelrsep = 0.5,
    labelrelrot = true, labelrelangle = 0,
    color = "black", linewidth = 1, linestyle = "-",
    colorDash="gray", left=0.20, right=0.80, bottom=0.20, top=0.80,
    fancy=false)`

# Description

This function draws a phasor with magnitude between 0 and 1 on the left subplot
of a figure and a sine diagram on the right subplot of the figure. Such graph
is used in electrical engineering to explain the relationship between phasors
and time domain wave forms.

# Variables

`mag` Magnitude of displayed phasor; shall be between 0 and 1;
default value = 1

`phi` Phase angle of the phasor; default value = 0

`add` When calling this function the first time, `add` shall be equal to
`false`, which is the default value. In this case a new figure with the
dimensions specified in `figsize` is created. In order to add a second phasor
and sine diagram to an existing figure, `add` has to be set `true`

`figsize` Size of the new figure, if `add` is equal to `false`; default value
= (6.6,2.5)

`xlabel` Label of x-axis of right subplot; default value ="ωt(°)" in LaTeX
notation

`ylabel` label of y-axis of right subplot; default value = "";  if more than one
phasors and sine diagram shall be drawn (`add = true`), this label is displayed
only once; therefore, one has to create the label of all phasors when function
`phasorsine` is called the first time for creating a figure

`maglabel` Label of positive and negative magnitude `mag` on the right subplot;
dafault value = "";

`phasorlabel` Label of phasor of left subplot; default value = `maglabel`

labelrsep` Radial per unit location of label (in direction of the phasor):
`labelrsep = 0` represents the shaft of the phasor and `labelrsep = 1` represents
the arrow hear of the phasor; default value = 0.5, i.e., the radial center
of the phasor

`labeltsep` Tangential per unit location of label: `labeltsep = 0` means that
the label is plotted onto the phasor; `labeltsep = 0.1` plots the label on top
of the phasor applying a displacement of 10% with respect to `ref`; `labeltsep =
-0.2` Plots the label below the phasor applying a displacement of 20% with
respect to `ref`; default value = 0.1

`labelrelrot` Relative rotation of label; if `labelrelrot == false` (default value)
then the label is not rotated relative to the orientation of the phasor;
otherwise the label is rotated relative to the phasor by the angle
`labelrelangle` (indicated in degrees)

`labelrelangle` Relative angle of label in degree with respect to phasor
orientation; this angle is only applied, it `labelrelrot == true`; this angle the
indicates the relative orientation of the label with respect to the
orientation of the phasor; default value = 0

`color` Color of the phasor; i.e., shaft and arrow head color; default
value = "black"

`linewidth` Line width of the phasor; default value = 1

`linestyle` Line style of the phasor; default value = "-"

`colorDash` Color of the dashed circle (left subplot) and the horizontal dashed
lines between the left and right subplot; default value = colorBlack4

`left` Left side of the figure; default value = 0.2

`right` Right side of the figure; default value = 0.85

`bottom` Bottom side of the figure; default value = 0.2

`top` Top side of the figure; default value = 0.85

`fancy` This affects how the axes of the right subplot are drawn; if `true`, the
annotate arrow is used instead of the axis arrow; in this case the arrow scales
with the figure size automatically; default value = `false`

# Example

Copy and paste code:

```julia
using Unitful, Unitful.DefaultSymbols, PyPlot, EE
phasorsine(1, 45°, ylabel=L"$u,i$", maglabel=L"$\hat{U}$", labelrsep=0.3,
    color=colorBlack2, linestyle=lineStyle2, fancy=true)
phasorsine(0.55, 0, add=true, maglabel=L"$\hat{I}$",fancy=true)
# save3fig("phasorsine",crop=true);
```
"""
function phasorsine(mag = 1,
    phi = 0;
    add = false,
    figsize = (6.6,2.5),
    xlabel = L"$\omega t$\,($^\circ $)",
    ylabel = "",
    maglabel = "",
    phasorlabel = maglabel,
    color = "black",
    linewidth = 1,
    linestyle = "-",
    labeltsep = 0.1,
    labelrsep = 0.5,
    labelrelrot = true,
    labelrelangle = 0,
    colorDash="gray",
    left=0.20,
    right=0.80,
    bottom=0.20,
    top=0.80,
    fancy=false)
    # https://matplotlib.org/tutorials/text/annotations.html#plotting-guide-annotation
    # https://matplotlib.org/users/annotations.html
    # https://stackoverflow.com/questions/17543359/drawing-lines-between-two-plots-in-matplotlib

    # Create figure
    if !add
        # Create new figure
        fig = figure(figsize=figsize)
        subplots_adjust(left=left, right=right, bottom=bottom, top=top)
    end
    # Create left subplot
    subplot(121)
    psi = collect(0:pi/500:2*pi)
    x = mag*cos.(psi)
    y = mag*sin.(psi)
    plot(x, y, color=colorDash, linewidth=1, linestyle=":",
        dash_capstyle="round")
    phasor(pol(mag,phi), ref=1,
        label=phasorlabel, labelrsep=labelrsep, labeltsep=labeltsep,
        labelrelrot=labelrelrot, labelrelangle=labelrelangle,
        color=color, linestyle=linestyle, linewidth=linewidth)
    axis("square")
    ax1 = gca()
    if !add
        xlim(-1.1,1.1)
        ylim(-1.1,1.1)
        ax1[:spines]["left"][:set_visible](false)
        ax1[:spines]["right"][:set_visible](false)
        ax1[:spines]["bottom"][:set_visible](false)
        ax1[:spines]["top"][:set_visible](false)
        xticks([])
        yticks([])
    end

    # Create right subplot
    subplot(122)
    yphi = mag*sin.(psi+phi)
    plot(psi*180/pi, yphi,
        color=color, linewidth=linewidth, linestyle=linestyle)

    ax2 = gca()
    if !add
        xlim(0,360)
        ylim(-1.1,1.1)
        xticks(collect(90:90:360))
        arrowaxes(xlabel=xlabel, ylabel=ylabel, fancy=fancy)
        yticks([-mag, 0, mag],[L"$-$"*maglabel, L"$0$", maglabel])
    else
        yticks_old = ax2[:get_yticks]()
        ytickslabel_old = ax2[:get_yticklabels]()
        yticks(cat(1, yticks_old, [-mag,mag]), cat(1, ytickslabel_old, [L"$-$"*maglabel,maglabel]))
    end
    # Dotted line of phasor projection
    con = matplotlib[:patches][:ConnectionPatch](
        xyA=(360,mag*sin(phi)), xyB=(mag*cos(phi), mag*sin(phi)),
        coordsA="data", coordsB="data",
        axesA=ax2, axesB=ax1, color=colorBlack4,
        linewidth=lineWidth4, linestyle=":", clip_on=false)
    ax2[:add_artist](con)
    # Dotted line of maximum
    con = matplotlib[:patches][:ConnectionPatch](
        xyB=(mod(90-phi*180/pi,360),mag), xyA=(0, mag),
        coordsA="data", coordsB="data",
        axesA=ax2, axesB=ax2, color=colorBlack4,
        linewidth=lineWidth4, linestyle=":", clip_on=false)
    ax2[:add_artist](con)
    # Dotted line of minimum
    con = matplotlib[:patches][:ConnectionPatch](
        xyB=(mod(270-phi*180/pi,360),-mag), xyA=(0, -mag),
        coordsA="data", coordsB="data",
        axesA=ax2, axesB=ax2, color=colorBlack4,
        linewidth=lineWidth4, linestyle=":", clip_on=false)
    ax2[:add_artist](con)
end
